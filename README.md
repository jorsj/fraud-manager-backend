# Fraud Manager Backend

This project implements a backend service designed to be used as a webhook for a Dialogflow CX agent. Its primary purpose is to detect and prevent potential fraud by analyzing the calling patterns of phone numbers interacting with the system.

The service checks if a phone number has been used to query an excessive number of different national IDs within configurable time periods. It can also manually block phone numbers.

## Features

*   **Fraud Detection**: Automatically blocks phone numbers that query too many distinct national IDs in a given day, week, or month.
*   **Manual Blocking**: Supports a manual blocklist for immediate action by customer service agents.
*   **Asynchronous Processing**: Fraud checks are run asynchronously to ensure the user in the call receives a fast response.
*   **Dialogflow CX Integration**: Responds in the format expected by Dialogflow CX, setting a session parameter to control the conversation flow.
*   **Google Cloud Native**: Designed for easy deployment and operation on Google Cloud Run, using Firestore as its database.

## Architecture

The application is built with Python using the **FastAPI** framework and is served by **Uvicorn**. It exposes two main webhook endpoints that Dialogflow CX calls in sequence, along with a healthcheck endpoint.

1.  A call arrives at Dialogflow CX.
2.  Dialogflow CX triggers a webhook to the `/phone-numbers:check` endpoint.
3.  The service checks if the phone number is in the `blocked_phone_numbers` collection.
    *   If **blocked**, it immediately responds to Dialogflow telling it to block the interaction.
    *   If **not blocked**, it responds to Dialogflow to allow the interaction.
4.  If allowed, Dialogflow CX proceeds and triggers a second webhook to the `/queries` endpoint.
5.  The `/queries` endpoint registers the query details and triggers a background task.
6.  The background task runs the fraud detection logic. It checks if the phone number has been associated with too many distinct national IDs. If a rule is violated, the number is added to the `blocked_phone_numbers` collection for future checks.

## Firestore Database Design

The service relies on two main Firestore collections:

**`queries`**: Stores a record of each valid query made. Each document represents an interaction.
*   **Document ID**: Auto-generated by Firestore.
*   **Fields**:
    *   `phone_number` (String): The caller's phone number in E.164 format (e.g., `+56912345678`).
    *   `national_id` (String): The National ID that was queried.
    *   `query_timestamp` (Timestamp): The exact date and time of the query, crucial for period-based filtering.

**`blocked_phone_numbers`**: Contains phone numbers that have been manually or automatically blocked.
*   **Document ID**: The phone number to be blocked. Using the number as the ID allows for very fast and efficient existence checks.
*   **Fields (Optional for auditing)**:
    *   `reason` (String): Reason for the block (e.g., "Reported by customer for fraudulent call" or "Automatic block (rule: week period)").
    *   `block_timestamp` (Timestamp): When the block was applied.
    *   `agent_id` (String): Identifier of the agent or process that performed the block (e.g., "automatic_block").

## Prerequisites

*   [Google Cloud SDK (`gcloud`)](https://cloud.google.com/sdk/docs/install)
*   [Podman](https://podman.io/getting-started/installation) (or Docker)
*   Python 3.13

## Local Development

The `run.sh` script builds the container image and runs it locally using Podman.

### Steps

1.  **Authenticate with Google Cloud:**
    Ensure you have authenticated your local environment to access Google Cloud services. The script requires the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to be set to the path of your service account key file.
    ```bash
    export GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/keyfile.json"
    ```

2.  **Run the script:**
    Execute the script to start the container. It will prompt you for your Google Cloud Project ID and the Firestore Database ID.
    ```bash
    ./run.sh
    ```
    The service will be available on `http://localhost:8080`.

## Deployment

The `deploy.sh` script provides an interactive guide to deploy the service to Google Cloud Run.

### Steps

1.  **Make the script executable:**
    ```bash
    chmod +x deploy.sh
    ```

2.  **Run the deployment script:**
    ```bash
    ./deploy.sh
    ```
    The script will prompt you for the following information:
    *   **Google Cloud Project ID**
    *   **GCP Region**
    *   **Cloud Run Service Name**
    *   **Service Account Name**
    *   **Firestore Database ID**

    It will then perform the following actions:
    *   Enable the required Google Cloud APIs.
    *   Create the Firestore database and a composite index if they don't exist.
    *   Create a dedicated service account with the necessary permissions.
    *   Build the container image using Cloud Build and deploy it to Cloud Run.

Upon successful deployment, the script will output the URL of the service, which you can use as the webhook endpoint in Dialogflow CX.

## Testing

The `test.sh` script sends a sample POST request to a deployed service endpoint, mimicking a call from Dialogflow CX.

### Steps

1.  **Authenticate with gcloud:**
    Ensure you are logged in with a user or service account that has the "Cloud Run Invoker" role for the deployed service.
    ```bash
    gcloud auth login
    ```

2.  **Make the script executable:**
    ```bash
    chmod +x test.sh
    ```

3.  **Run the test script:**
    ```bash
    ./test.sh
    ```
    The script will prompt you for:
    *   The **URL of the deployed service**.
    *   A **National ID** to test.
    *   A **Phone Number** to test.

    It will then acquire an authentication token and send a POST request, printing the JSON response from the service.

## Configuration

The application is configured via environment variables.

| Variable                    | Description                                                                      | Default Value       |
| --------------------------- | -------------------------------------------------------------------------------- | ------------------- |
| `PORT`                      | The port on which the application listens inside the container.                  | `8080`              |
| `FIRESTORE_DATABASE_ID`     | The ID of the Firestore database to use.                                         | `fraud-manager`         |
| `MAX_DISTINCT_NATIONAL_IDS` | The maximum number of distinct national IDs a phone can query before being blocked. | `3`                 |
| `DAY_PERIOD`                | The duration in days for the "day" fraud check period.                           | `1`                 |
| `WEEK_PERIOD`               | The duration in days for the "week" fraud check period.                          | `7`                 |
| `MONTH_PERIOD`              | The duration in days for the "month" fraud check period.                         | `30`                |

## API Endpoints

### `GET /healthcheck`

A simple endpoint to verify that the service is running.

**Response Body:**
```json
{
  "status": "ok"
}
```

### `POST /phone-numbers:check`

This is the first webhook called by Dialogflow CX to check if a phone number is blocked.

**Request Body:**
```json
{
  "payload": {
    "telephony": {
      "caller_id": "+56912345678"
    }
  }
}
```

**Response Body (Allowed):**
```json
{
  "fulfillment_response": {
    "messages": [
      {
        "text": {
          "text": [
            "Número de teléfono permitido."
          ]
        }
      }
    ]
  },
  "sessionInfo": {
    "parameters": {
      "block": false
    }
  }
}
```

**Response Body (Blocked):**
```json
{
  "fulfillment_response": {
    "messages": [
      {
        "text": {
          "text": [
            "Este número de teléfono ha sido bloqueado por actividad sospechosa."
          ]
        }
      }
    ]
  },
  "sessionInfo": {
    "parameters": {
      "block": true
    }
  }
}
```

### `POST /queries`

This is the second webhook called by Dialogflow CX (if the number was not blocked) to register the query and trigger the fraud detection analysis.

**Request Body:**
```json
{
  "sessionInfo": {
    "parameters": {
      "national_id": "12.345.678-9"
    }
  },
  "payload": {
    "telephony": {
      "caller_id": "+56912345678"
    }
  }
}
```

**Response Body:**
```json
{
  "status": "ok"
}
```
