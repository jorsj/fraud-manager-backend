# Fraud Manager Backend

This project implements a backend service designed to be used as a webhook for a Dialogflow CX agent. Its primary purpose is to detect and prevent potential fraud by analyzing the calling patterns of phone numbers interacting with the system.

The service checks if a phone number has been used to query an excessive number of different national IDs within configurable time periods. It can also manually block phone numbers.

## Features

*   **Fraud Detection**: Automatically blocks phone numbers that query too many distinct national IDs in a given day, week, or month.
*   **Manual Blocking**: Supports a manual blocklist for immediate action by customer service agents.
*   **Asynchronous Processing**: Fraud checks are run asynchronously to ensure the user in the call receives a fast response.
*   **Dialogflow CX Integration**: Responds in the format expected by Dialogflow CX, setting a session parameter to control the conversation flow.
*   **Google Cloud Native**: Designed for easy deployment and operation on Google Cloud Run, using Firestore as its database.

## Architecture

The application is built with Python using the Flask framework and is served by Gunicorn. It exposes a single webhook endpoint that Dialogflow CX calls.

1.  A call arrives at Dialogflow CX.
2.  Dialogflow CX triggers a webhook, sending a request to this Cloud Run service. The request includes the caller's phone number and the national ID they are querying.
3.  The service immediately records the query in Firestore.
4.  It checks if the phone number is in the `blocked_phone_numbers` collection.
    *   If **blocked**, it immediately responds to Dialogflow telling it to block the interaction.
    *   If **not blocked**, it responds to Dialogflow to allow the interaction and, in the background, triggers an asynchronous process.
5.  The asynchronous process checks the fraud rules based on the query history for that phone number. If the rules are violated, the number is added to the `blocked_phone_numbers` collection for future requests.

## Firestore Database Design

The service relies on two main Firestore collections:

**`queries`**: Stores a record of each valid query made. Each document represents an interaction.
*   **Document ID**: Auto-generated by Firestore.
*   **Fields**:
    *   `phone_number` (String): The caller's phone number in E.164 format (e.g., `+56912345678`).
    *   `national_id` (String): The National ID that was queried.
    *   `query_timestamp` (Timestamp): The exact date and time of the query, crucial for period-based filtering.

**`blocked_phone_numbers`**: Contains phone numbers that have been manually or automatically blocked.
*   **Document ID**: The phone number to be blocked. Using the number as the ID allows for very fast and efficient existence checks.
*   **Fields (Optional for auditing)**:
    *   `reason` (String): Reason for the block (e.g., "Reported by customer for fraudulent call" or "Automatic block (rule: week period)").
    *   `block_timestamp` (Timestamp): When the block was applied.
    *   `agent_id` (String): Identifier of the agent or process that performed the block (e.g., "automatic_block").

## Prerequisites

*   [Google Cloud SDK (`gcloud`)](https://cloud.google.com/sdk/docs/install)
*   [Podman](https://podman.io/getting-started/installation) (or Docker)
*   Python 3.12

## Local Development

The `run.sh` script builds the container image and runs it locally using Podman.

### Steps

1.  **Authenticate with Google Cloud:**
    Ensure you have authenticated your local environment to access Google Cloud services. The script requires the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to be set to the path of your service account key file.
    ```bash
    export GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/keyfile.json"
    ```

2.  **Run the script:**
    Execute the script to start the container. It will prompt you for your Google Cloud Project ID and the Firestore Database ID.
    ```bash
    ./run.sh
    ```
    The service will be available on `http://localhost:8080`.

## Deployment

The `deploy.sh` script provides an interactive guide to deploy the service to Google Cloud Run.

### Steps

1.  **Make the script executable:**
    ```bash
    chmod +x deploy.sh
    ```

2.  **Run the deployment script:**
    ```bash
    ./deploy.sh
    ```
    The script will prompt you for the following information:
    *   **Google Cloud Project ID**
    *   **GCP Region**
    *   **Cloud Run Service Name**
    *   **Service Account Name**
    *   **Firestore Database ID**

    It will then perform the following actions:
    *   Enable the required Google Cloud APIs.
    *   Create the Firestore database and a composite index if they don't exist.
    *   Create a dedicated service account with the necessary permissions.
    *   Build the container image using Cloud Build and deploy it to Cloud Run.

Upon successful deployment, the script will output the URL of the service, which you can use as the webhook endpoint in Dialogflow CX.

## Testing

The `test.sh` script sends a sample POST request to a deployed service endpoint, mimicking a call from Dialogflow CX.

### Steps

1.  **Authenticate with gcloud:**
    Ensure you are logged in with a user or service account that has the "Cloud Run Invoker" role for the deployed service.
    ```bash
    gcloud auth login
    ```

2.  **Make the script executable:**
    ```bash
    chmod +x test.sh
    ```

3.  **Run the test script:**
    ```bash
    ./test.sh
    ```
    The script will prompt you for:
    *   The **URL of the deployed service**.
    *   A **National ID** to test.
    *   A **Phone Number** to test.

    It will then acquire an authentication token and send a POST request, printing the JSON response from the service.

## Configuration

The application is configured via environment variables.

| Variable                    | Description                                                                      | Default Value       |
| --------------------------- | -------------------------------------------------------------------------------- | ------------------- |
| `PORT`                      | The port on which the application listens inside the container.                  | `8080`              |
| `FIRESTORE_DATABASE_ID`     | The ID of the Firestore database to use.                                         | `fraud-manager`         |
| `MAX_DISTINCT_NATIONAL_IDS` | The maximum number of distinct national IDs a phone can query before being blocked. | `3`                 |
| `DAY_PERIOD`                | The duration in days for the "day" fraud check period.                           | `1`                 |
| `WEEK_PERIOD`               | The duration in days for the "week" fraud check period.                          | `7`                 |
| `MONTH_PERIOD`              | The duration in days for the "month" fraud check period.                         | `30`                |

## API Endpoint

### `POST /`

This is the main webhook endpoint for Dialogflow CX.

**Request Body:**

The service expects a JSON payload with the following structure:

```json
{
  "sessionInfo": {
    "parameters": {
      "national_id": "12.345.678-9"
    }
  },
  "payload": {
    "telephony": {
      "caller_id": "+56912345678"
    }
  }
}
```

**Response Body:**

The service returns a JSON object that sets the `block` session parameter for Dialogflow CX.

*   **On Success (Allowed):**

```json
{
  "fulfillment_response": {
    "messages": [
      {
        "text": {
          "text": [
            "Número de teléfono permitido."
          ]
        }
      }
    ]
  },
  "sessionInfo": {
    "parameters": {
      "block": false
    }
  }
}
```

*   **On Success (Blocked):**

```json
{
  "fulfillment_response": {
    "messages": [
      {
        "text": {
          "text": [
            "Este número de teléfono ha sido bloqueado por actividad sospechosa. Por favor, contacte con soporte."
          ]
        }
      }
    ]
  },
  "sessionInfo": {
    "parameters": {
      "block": true
    }
  }
}
```
